# **Руководство пользователя по GIT**
## Что такое Git и зачем он нужен?
***Git*** - это консольная утилита, для отслеживания и ведения истории изменения файлов, в вашем проекте. Чаще всего его используют для кода, но можно и для других файлов. Например, для картинок - полезно для дизайнеров.

С помощью Git-a вы можете откатить свой проект до более старой версии, сравнивать, анализировать или сливать свои изменения в репозиторий.

Репозиторием называют хранилище вашего кода и историю его изменений. Git работает локально и все ваши репозитории хранятся в определенных папках на жестком диске.
___
## Первые настройки
**1. Установим имя пользователя.** 

- Введите команду:

  git config --global user.name "ваше имя"

**2. Установим email.**

- Введите команду:

  git config --global user.email "ваш емэйл"

**3. Создаем репозиторий.**

- Введите команду:

  git init

#### **Ура! Теперь Git отслеживает изменения.**
___
## Основные команды
**git status** - 
показывает текущее состояние файлов и папок в репозитории

**git add [file]** - добавить файл для отслеживания его состояния. Если этого не прописать, то изменения файла не будут попадать в коммиты.

**git diff** - отобразить разницу между изменениями без коммитов

**git commit -m “[descriptive message]”** - зафиксировать новые правки с комментарием в ""

**git branch** - отобразить список всех веток репозитория

**git branch [branch-name]** - создать новую ветку с конкретным названием

**git checkout** - переключиться на ветку, на коммит, на файл

**git checkout master** - переключиться на ветку мастер

**git merge [branch-name]** - объединить текущую ветку с указанной в команде

**git log** - показать все коммиты в текущей ветке

**git reset [file]** - отмена отслеживания файла, с сохранением файла

**git rm [file]** - удалить физически файл и отменить отслеживание

**git mv [existing-path] [new-path]** - перемещение файлов

**git fetch [alias]** - скачать изменения из удаленного репозитория

**git push [alias] [branch]** - закачать на сервер

**git pull** - скачать изменения и применить их к твоим файлам
___
## Подробные инструкции
* Настройка репозитория
* Сохранение изменений
* Проверка репозитория
* Отмена изменений
* Переписывание истории

### **1. Настройка репозитория**

В данном руководстве обсуждаются следующие основные вопросы:

1.1 Инициализация нового репозитория Git

1.2 Клонирование существующего репозитория Git

1.3 Коммит измененной версии файла в репозиторий

1.4 Конфигурирование репозитория Git для удаленной совместной работы

1.5 Распространенные команды для управления версиями Git

**1.1 Инициализация нового репозитория: git init**

Для создания нового репозитория используется команда git init. Команду git init выполняют только один раз для первоначальной настройки нового репозитория. Выполнение команды приведет к созданию нового подкаталога .git в вашем рабочем каталоге. Кроме того, будет создана новая главная ветка.

***Создание версии существующего проекта с использованием нового репозитория Git***

В этом примере предполагается, что у вас уже есть папка проекта, в которой вы и хотите создать репозиторий. Выполните команду cd для перехода к папке проекта, а затем выполните команду git init.

<table><tr><td bgcolor = #008000> cd /path/to/your/existing/code 

git init </td> </tr> </table>

Указание в команде git init существующего каталога проекта приведет к исполнению описанной выше инициализации, но только на уровне этого каталога проекта.

<table> <tr> <td bgcolor = #008000> git init "project directory" </td> </tr> </table>

Перейдите на страницу git init, чтобы получить подробные сведения о команде git init.

**1.2 Клонирование существующего репозитория: git clone**

Если проект уже настроен в центральном репозитории, наиболее распространенным способом создать его локальный клон является команда clone. Клонирование, как и команда git init, обычно выполняется один раз. Получив рабочую копию, разработчик в дальнейшем выполняет все операции контроля версий из своего локального репозитория.

<table> <tr> <td bgcolor = #008000> git clone "repo url" </td> </tr> </table>
Команду git clone выполняют для создания копии (клонирования) удаленного репозитория. В качестве параметра в команду git clone передается URL-адрес репозитория. Git поддерживает несколько различных сетевых протоколов и соответствующих форматов URL-адресов. В этом примере используется SSH-протокол Git. URL-адреса SSH в Git имеют следующий шаблон: 
<table> <tr> <td bgcolor = #008000>git@HOSTNAME:USERNAME/REPONAME.git</td> </tr> </table>

Пример URL-адреса SSH в Git имеет вид: git@bitbucket.org:rhyolight/javascript-data-store.git, а ниже приведены значения шаблонных параметров:

* HOSTNAME: bitbucket.org
* USERNAME: rhyolight
* REPONAME: javascript-data-store

После исполнения команды последние версии файлов из главной ветки удаленного репозитория будут загружены и помещены в новый каталог. Имя нового каталога будет соответствовать параметру REPONAME. В данном случае это javascript-data-store. В каталоге будет вся история удаленного репозитория и только что созданная главная ветка.

Дополнительную информацию об использовании команды git clone и поддерживаемых форматах URL-адресов в Git см. на странице git clone.

**1.3 Сохранение изменений в репозитории: git add и git commit**

У вас появился репозиторий, созданный путем клонирования или инициализации. Теперь вы можете выполнять коммиты изменений в версиях файлов. В следующем примере предполагается, что вы настроили проект в каталоге /path/to/project. В этом примере предлагаются следующие шаги.

* Измените каталоги на /path/to/project
* Создайте новый файл CommitTest.txt с текстом ~«тест для обучения работе с Git»~
* С помощью команды git add добавьте файл CommitTest.txt в репозиторий проиндексированных файлов
* Создайте новый коммит с комментарием, описывающим, что именно было изменено в коммите
<table> <tr> <td bgcolor = #008000>
cd /path/to/project 

echo "test content for git tutorial" >> CommitTest.txt

git add CommitTest.txt 
 
git commit -m "added CommitTest.txt to the repo"</td> </tr> </table>

По завершении этого примера файл CommitTest.txt добавится к истории репозитория, и репозиторий будет отслеживать последующие изменения в файле.

В этом примере представлены две новые команды в Git: add и commit. Этот очень упрощенный пример. Подробнее обе команды объяснены на страницах git add и git commit. Команду git add часто используют с флагом --all. Команда git add --all добавляет все измененные и неотслеживаемые файлы в репозиторий и обновляет дерево изменений репозитория.

**1.4 Совместная работа в разных репозиториях: git push**

Важно понимать, что рабочая копия в Git существенно отличается от рабочей копии, получаемой при загрузке исходного кода из репозитория SVN. В отличие от SVN, в Git нет разницы между рабочими копиями и центральным репозиторием — все они являются полноценными репозиториями Git.

Поэтому совместная работа в Git принципиально отличается от совместной работы в SVN. В SVN работа строится на отношении между центральным репозиторием и рабочей копией, а модель совместной работы в Git основана на взаимодействии между репозиториями. Вместо загрузки рабочей копии в центральный репозиторий SVN в Git вы отправляете коммиты из одного репозитория в другой или копируете их в обратном направлении.

Вы легко можете задавать особую роль определенным репозиториям Git. Например, обозначив один из репозиториев Git как «центральный», вы можете воспроизвести централизованный процесс с использованием Git. Такой подход требует общих договоренностей, он не встроен в саму систему контроля версий.

***Сравнение чистых и клонированных репозиториев***
Если в предыдущем разделе («Инициализация нового репозитория») для настройки локального репозитория вы использовали команду git clone, ваш репозиторий уже готов к удаленной совместной работе. Команда git clone автоматически настроит репозиторий, в котором значение remote будет соответствовать URL-адресу Git, из которого был клонирован репозиторий. Это означает, что после изменений файла и выполнения коммита вы можете сразу выполнить команду git push, чтобы отправить эти изменения в удаленный репозиторий.

Если вы использовали команду git init для создания репозитория с нуля, у вас не будет удаленного репозитория, в который можно помещать изменения. Зачастую для инициализации нового репозитория пользователь переходит на сервис Git-хостинга (например, Bitbucket) и создает репозиторий там. Данный сервис предоставит URL-адрес Git, который затем можно добавить в локальный репозиторий Git. После этого можно выполнять команду git push в репозиторий на хостинге. После создания удаленного репозитория на выбранном хостинге вам понадобится обновить локальный репозиторий, выполнив привязку. Этот процесс описывается далее в руководстве по установке и настройке.

Если вы предпочитаете поддерживать собственный удаленный репозиторий, вам нужно создать «чистый репозиторий». Для этого команды git init и git clone принимают аргумент --bare. Наиболее популярная причина использования чистого репозитория — создание удаленного центрального репозитория Git

**1.5 Конфигурирование и настройка: git config**

После настройки удаленного репозитория его URL-адрес нужно добавить в локальный файл git config, а также создать вышестоящую ветку для локальных веток. Такую возможность предоставляет команда git remote.

<table> <tr> <td bgcolor = #008000>git remote add "remote_name" "remote_repo_url"</td> </tr> </table>

Эта команда привяжет удаленный репозиторий по адресу  к ссылке в вашем локальном репозитории . После привязки удаленного репозитория в него можно будет отправлять локальные ветки с помощью команды push.

<table> <tr> <td bgcolor = #008000> git push -u "remote_name" "local_branch_name" </td> </tr> </table>
Эта команда поместит ветку локального репозитория с именем < local_branc_name > в удаленный репозиторий < remote_name >.

Дополнительную информацию о команде git remote см. на странице удаленной работы в Git.

Помимо конфигурирования URL-адреса удаленного репозитория, вам может потребоваться установить глобальные параметры Git, например имя пользователя или электронный адрес. Команда git config позволяет настроить инсталляцию Git (или отдельный репозиторий) из командной строки. С помощью этой команды можно установить любые настройки: от информации о пользователе до его предпочтений и характеристик репозитория. Ниже перечислены распространенные варианты конфигурации.

Git хранит варианты конфигурации в трех различных файлах, позволяющих ограничивать область видимости на уровне отдельных репозиториев (локальный), пользователя (глобальный) или всей системы (системный):

* Локальный: /.git/config — настройки на уровне репозитория.
* Глобальный: /.gitconfig — настройки на уровне пользователя. Здесь хранятся настройки с флагом --global.
* Системный: $(prefix)/etc/gitconfig — настройки на уровне всей системы.

Укажите имя автора, которое будет использоваться для всех коммитов в текущем репозитории. Обычно для настройки параметров конфигурации для текущего пользователя используется флаг --global.

<table> <tr> <td bgcolor = #008000>git config --global user.name "name"</td> </tr> </table>

Эта команда задает имя автора, которое будет использоваться для всех коммитов, выполненных текущим пользователем.

Добавление аргумента --local или выполнение команды без параметра уровня конфигурации приведет к установке значения user.name для текущего локального репозитория.

<table> <tr> <td bgcolor = #008000>git config --local user.email "email"</td> </tr> </table>

Эта команда задает адрес электронной почты автора, который будет использоваться для всех коммитов, выполненных текущим пользователем.

<table> <tr> <td bgcolor = #008000>git config --global alias."alias-name" <git-command></td> </tr> </table>

Создайте быстрые клавиши для команды Git. Это мощная возможность для создания собственных комбинаций клавиш для часто используемых команд Git. Ниже показан упрощенный пример:

<table> <tr> <td bgcolor = #008000>git config --global alias.ci commit</td> </tr> </table>

Так создается команда ci, которую можно использовать как сокращение команды git commit. Подробнее об алиасах в Git см. на странице git config.

<table> <tr> <td bgcolor = #008000>git config --system core.editor "editor"</td> </tr> </table>

Выберите текстовый редактор, используемый для таких команд, как git commit, для всех пользователей текущего компьютера. Аргумент  должен представлять собой команду, запускающую нужный редактор (например, vi). В этом примере представлен аргумент --system. Аргумент --system устанавливает настройку на уровне всей системы, включая всех пользователей и все репозитории на компьютере. Дополнительную информацию об уровнях конфигурации см. на странице удаленной работы с git.

<table> <tr> <td bgcolor = #008000>git config --global --edit</td> </tr> </table>

В текстовом редакторе откройте файл глобальной конфигурации для редактирования вручную. Подробное руководство по настройке текстового редактора для Git см. на странице Git config.

**Пояснения**

Все варианты конфигурации сохраняются в обычных текстовых файлах, так что команда git config — это всего лишь удобный интерфейс командной строки. Как правило, установку Git следует настраивать только при начале работы на новом компьютере. В подавляющем большинстве случаев понадобится только флаг --global. Одно из важных исключений — необходимость переписать электронный адрес автора. Вы можете поставить личный электронный адрес для личных репозиториев и репозиториев с открытым исходным кодом, а рабочий электронный адрес — для рабочих репозиториев.

Git хранит варианты конфигурации в трех различных файлах, что позволяет ограничивать область видимости на уровне отдельных репозиториев, пользователей или всей системы.

* /.git/config — настройки на уровне репозитория.
* ~/.gitconfig — личные настройки пользователя. Здесь хранятся настройки с флагом --global.
* $(prefix)/etc/gitconfig — настройки на уровне всей системы.

Если параметры, указанные в этих файлах, конфликтуют, локальные настройки переопределяют пользовательские настройки, которые в свою очередь переопределяют системные настройки. Если вы откроете один из этих файлов, вы увидите нечто подобное:

<table> <tr> <td bgcolor = #008000>[user] name = John Smith email = john@example.com [alias] st = status co = checkout br = branch up = rebase ci = commit [core] editor = vim</td> </tr> </table>

Вы можете изменить эти значения вручную, эффект будет аналогичен использованию команды git config.

***Пример***

В первую очередь после установки Git требуется указать свое имя и адрес электронной почты, а также настроить некоторые параметры по умолчанию. Пример типичной начальной конфигурации показан далее.

Представьтесь репозиторию Git с помощью команды git config

<table> <tr> <td bgcolor = #008000>git --global user.name "John Smith" git config --global user.email john@example.com</td> </tr> </table>

Выберите любимый текстовый редактор

<table> <tr> <td bgcolor = #008000>git config --global core.editor vim</td> </tr> </table>

Добавьте алиасы по типу SVN

<table> <tr> <td bgcolor = #008000>git config --global alias.st status 
git config --global alias.co checkout 
git config --global alias.br branch 
git config --global alias.up rebase 
git config --global alias.ci commit</td> </tr> </table>

Создастся файл ~ /.gitconfig, описанный в предыдущем разделе. Подробную информацию о команде git config см. на странице Git config.

***Резюме***

Мы показали, как создать репозиторий Git двумя способами: git init и git clone. Этим руководством можно пользоваться при необходимости управления исходным кодом ПО или другим контентом, при хранении которого требуется поддерживать версионность. Кроме того, были представлены команды git add, git commit, git push и git remote и показаны простые примеры их использования.

### **2. Сохранение изменений**
* git add 
* git commit 
* git diff 
* git stash 
* .gitignore

В Git и других системах управления версиями концепция сохранения проработана более детально, чем в текстовых процессорах или других традиционных приложениях для редактирования файлов. Традиционный термин «сохранение» в программировании синонимичен понятию коммита в Git. Коммит в Git является эквивалентом сохранения. Традиционное сохранение — это операция файловой системы, которая используется для перезаписи существующего файла или записи нового. В отличие от нее, коммит Git выполняется над набором файлов и каталогов.

Процессы сохранения в Git и SVN также отличаются. Коммиты, или «фиксации», в SVN — это операции передачи на централизованный удаленный сервер. Это означает, что для «сохранения» изменений в проекте коммитам SVN необходим доступ в Интернет. Коммиты Git можно создавать и выполнять локально, а затем по мере необходимости отправлять на удаленный сервер с помощью команды git push -u origin main. Различие этих двух методов объясняется фундаментальными отличиями в архитектуре. В Git реализована модель распределенного приложения, а в SVN — модель централизованного приложения. Обычно распределенные приложения более устойчивы, поскольку не имеют единой точки отказа, такой как централизованный сервер.

В Git имеется дополнительный механизм сохранения, который называется «stash». Stash — это временная область для хранения изменений, не готовых к коммиту. Команда stash работает с рабочим каталогом (первым из трех деревьев) и имеет множество вариантов применения. Подробнее см. на странице команды git stash.

Репозиторий Git можно настроить на игнорирование определенных файлов или каталогов. В этом случае Git не будет сохранять изменения в игнорируемом контенте. В Git имеется несколько способов настройки для управления списком игнорирования. Более подробно настройка игнорирования в Git рассматривается на странице git ignore.

## **git add**
Команда git add добавляет изменение из рабочего каталога в раздел проиндексированных файлов. Она сообщает Git, что вы хотите включить изменения в конкретном файле в следующий коммит. Однако на самом деле команда git add не оказывает существенного влияния на репозиторий: изменения регистрируются в нем только после выполнения команды git commit.

Наряду с этими командами вам понадобится команда git status, которая показывает состояние рабочего каталога и раздела проиндексированных файлов.

**Порядок действий**

Команды git add и git commit составляют основу рабочего процесса Git. Эти две команды должен изучить и понимать каждый пользователь Git, независимо от модели совместной работы, принятой в его команде. Эти команды используются для записи версий проекта в историю репозитория.

Работа над проектом ведется по стандартной схеме «редактирование — индексирование — коммит». Сначала вы редактируете файлы в рабочем каталоге. Когда вы будете готовы сохранить копию текущего состояния проекта, вы индексируете изменения командой git add. Затем вы вызываете команду git commit, которая добавляет проиндексированный снимок состояния в историю проекта. Для отмены коммита или проиндексированного снимка состояния используется команда git reset.

Для полноценного процесса совместной работы в Git помимо git add и git commit необходима третья команда — git push. git push используется для отправки подтвержденных изменений в удаленные репозитории для совместной работы, чтобы к набору сохраненных изменений могли получить доступ другие участники команды.

Команду git add не следует путать с командой svn add, которая добавляет файл в репозиторий. git add работает на более абстрактном уровне изменений. Это означает, что команду git add необходимо вызывать при каждом изменении файла, тогда как svn add вызывается для каждого файла только один раз. Это может показаться избыточным, но такой рабочий процесс облегчает поддержание порядка в проекте.

**Раздел проиндексированных файлов**

Основное назначение команды git add состоит в переносе ожидающих изменений из рабочего каталога в раздел проиндексированных файлов Git. Раздел проиндексированных файлов — это уникальная возможность Git, и если вы прежде работали с SVN (или даже с Mercurial), вам потребуется некоторое время, чтобы освоить ее. Этот раздел удобно рассматривать как буфер между рабочим каталогом и историей проекта. Раздел проиндексированных файлов является одним из «трех деревьев» Git, наряду с рабочим каталогом и историей коммитов.

Вместо того чтобы подтверждать все изменения, внесенные после последнего коммита, вы можете сгруппировать связанные изменения в определенные снимки состояний в разделе проиндексированных файлов, прежде чем выполнять их коммит в историю проекта. Это означает, что вы можете внести различные изменения в несвязанные файлы, а затем вернуться назад и разбить их на логические коммиты (добавляя в раздел проиндексированных файлов связанные изменения и поэтапно выполняя коммиты для отдельных групп изменений). В Git, как и в любой системе контроля версий, важно создавать мелкие коммиты, чтобы можно было легко отслеживать ошибки и отменять изменения с минимальным влиянием на остальной проект.

**Распространенные опции**

- <table><tr><td bgcolor = #008000>git add "file"</td> </tr> </table>

Проиндексировать все изменения в файле <file> для следующего коммита.

- <table><tr><td bgcolor = #008000>git add "directory"</td> </tr> </table> 
Проиндексировать все изменения в каталоге <directory> для следующего коммита.

- <table><tr><td bgcolor = #008000>git add -p</td> </tr> </table>

Начать интерактивный сеанс индексирования, во время которого вы сможете выбрать части файла, которые будут добавлены в следующий коммит. Команда представит фрагмент изменений и предложит вам ввести команду. Введите y, чтобы проиндексировать фрагмент; n, чтобы игнорировать фрагмент; s, чтобы разбить его на более мелкие фрагменты; e, чтобы вручную отредактировать фрагмент; q, чтобы завершить работу с командой.

**Примеры**

Когда вы только начинаете новый проект, команда git add выполняет ту же функцию, что и svn import. Чтобы создать первичный коммит текущего каталога, используйте следующие две команды:

<table><tr><td bgcolor = #008000>git add .

git commit</td> </tr> </table>

После того как начнется работа над проектом, можно будет добавить новые файлы, указав путь в команде git add:

<table><tr><td bgcolor = #008000>git add hello.py

git commit</td> </tr> </table>

Приведенную выше команду можно также использовать для регистрации изменений в существующих файлах. Вспомним, что Git не различает индексацию изменений в новых файлах и в файлах, которые уже добавлены в репозиторий.

**Резюме**

Подведем итоги. Команда git add — это первая команда в цепочке операций, предписывающей Git «сохранить» снимок текущего состояния проекта в истории коммитов. Когда git add используется как отдельная команда, она переносит ожидающие изменения из рабочего каталога в раздел проиндексированных файлов. Команда git status проверяет текущее состояние репозитория; с ее помощью можно убедиться, что команда git add добавила нужные изменения. Команда git reset используется для отмены команды git add. Команда git commit сохраняет снимок состояния из раздела проиндексированных файлов в истории коммитов репозитория.

### **3. Git status: проверка репозитория**
* git status 
* git tag 
* git blame

**git status**

Команда git status отображает состояние рабочего каталога и раздела проиндексированных файлов. С ее помощью можно проверить индексацию изменений и увидеть файлы, которые не отслеживаются Git. Информация об истории коммитов проекта не отображается при выводе данных о состоянии. Для этого используется команда git log.

**Связанные команды git**
* git tag

Теги — это ссылки, указывающие на определенные точки в истории Git. Команда git tag обычно используется для захвата некой точки в истории, которая используется для релиза нумерованной версии (например, v1.0.1).

* git blame

Общее назначение git blame — отображение метаданных автора, связанных со строками, которые были внесены в файл при коммите. Таким образом можно проследить историю кода и выяснить, какой именно код был внесен в репозиторий, как это было сделано и по какой причине.

* git log

Команда git log отображает отправленные снимки состояния и позволяет просматривать и фильтровать историю проекта, а также проводить поиск по ней.

**Использование**

<table> <tr> <td bgcolor = #008000>git status</td> </tr> </table>
Выводит список проиндексированных и неотслеживаемых файлов, а также файлов, удаленных из индекса Git.

**Пояснения**

Команда git status относительно проста в использовании. Она показывает, какие изменения были внесены с помощью команд git add и git commit. Сообщения о состоянии также содержат инструкции по индексированию файлов либо отмене этой операции. В примере выходных данных ниже показаны три основные категории вызова git status:
<table> <tr> <td bgcolor = #008000>
# On branch main
# Changes to be committed:
# (use "git reset HEAD <file>..." to unstage)
#
#modified: hello.py
#
# Changes not staged for commit:
# (use "git add <file>..." to update what will be committed)
# (use "git checkout -- <file>..." to discard changes in working directory)
#
#modified: main.py
#
# Untracked files:
# (use "git add <file>..." to include in what will be committed)
#
#hello.pyc
</td> </tr> </table>

**Игнорирование файлов**

Неотслеживаемые файлы обычно подразделяются на две категории: файлы, недавно добавленные в проект и пока не отправленные в качестве коммитов, либо скомпилированные бинарные файлы (например, .pyc, .obj, .exe и т. д.). Включать файлы первой категории в выходные данные git status очень полезно, в то время как файлы второй категории могут затруднить отслеживание изменений в репозитории.

По этой причине в Git можно полностью игнорировать файлы, поместив пути к ним в специальный файл .gitignore. Каждый игнорируемый файл указывается в отдельной строке. При этом можно использовать символ * в качестве шаблона подстановки. Так, добавление следующего выражения в файл .gitignore в корневом каталоге проекта исключит скомпилированные модули Python из выходных данных git status:

<table> <tr> <td bgcolor = #008000>*.pyc</td> </tr> </table>

**Пример**

Перед отправкой изменений рекомендуется проверить состояние репозитория. Так вы сможете убедиться, что коммит включает только нужные данные. В следующем примере показано состояние репозитория до и после индексирования и отправки снимка состояния:

<table> <tr> <td bgcolor = #008000>
#Edit hello.py

git status

#hello.py is listed under "Changes not staged for commit"

git add hello.py

git status

#hello.py is listed under "Changes to be committed"

git commit

git status

#nothing to commit (working directory clean)</td> </tr> </table>

Первая строка данных о состоянии указывает на файл, который не был проиндексирован. Операция git add отражена во второй команде git status, а в последней строке данных сообщается, что элементы для коммита отсутствуют (рабочий каталог соответствует последнему коммиту). Для некоторых команд Git (например, git merge) требуется очистка рабочего каталога, чтобы исключить случайную перезапись изменений.

**git log**

Команда git log отображает отправленные снимки состояния и позволяет просматривать и фильтровать историю проекта, а также искать в ней конкретные изменения. С помощью git status можно просматривать рабочий каталог и раздел проиндексированных файлов, в то время как git log показывает только историю коммитов.

Существует множество вариантов для настройки выходных данных команды git log: от простой фильтрации коммитов до их отображения в пользовательском формате. Ниже показаны наиболее распространенные конфигурации git log.

**Использование**
* <table> <tr> <td bgcolor = #008000>git log</td> </tr> </table>

Выводит полную историю коммитов в стандартном формате. Если выходные данные занимают более одного экрана, можно выполнить прокрутку с помощью клавиши Пробел или нажать q для выхода.

* <table> <tr> <td bgcolor = #008000>git log -n <limit></td> </tr> </table>

Ограничивает число коммитов с помощью параметра . Так, при указании git log -n 3 отобразится только 3 коммита.

Записывает каждый коммит в одну строку. Так можно получить подробный обзор всей истории проекта.

* <table> <tr> <td bgcolor = #008000>git log --oneline</td> </tr> </table>

* <table> <tr> <td bgcolor = #008000>git log --stat</td> </tr> </table>

Кроме обычных данных git log указывается, какие файлы были изменены, а также относительное число добавленных или удаленных строк в каждом из них.

* <table> <tr> <td bgcolor = #008000>git log -p</td> </tr> </table>

Выводит патчи, соответствующие определенным коммитам. Это самое подробное представление истории проекта, поскольку так можно просмотреть полный список изменений каждого коммита.

* <table> <tr> <td bgcolor = #008000>git log --author="pattern"</td> </tr> </table>

Выполняет поиск коммитов конкретного автора. Аргумент  может быть обычной строкой или регулярным выражением.

* <table> <tr> <td bgcolor = #008000>git log --grep="pattern"</td> </tr> </table>

Выполняет поиск коммитов с сообщениями, соответствующими аргументу . Этот аргумент может быть обычной строкой или регулярным выражением.

* <table> <tr> <td bgcolor = #008000>git log "since".."until"</td> </tr> </table>

Отображает только коммиты в диапазоне значений < since > и < until >. Эти аргументы могут быть идентификаторами коммитов, именами веток, указателями HEAD или другими ссылками на версии.

* <table> <tr> <td bgcolor = #008000>git log "file"</td> </tr> </table>

Выводит только коммиты, содержащие указанный файл. Так можно удобно просмотреть историю конкретного файла.

* <table> <tr> <td bgcolor = #008000>git log --graph --decorate --oneline</td> </tr> </table>

Здесь содержится несколько полезных параметров: флаг --graph создает основанную на тексте диаграмму коммитов в левой части области сообщений коммитов; флаг --decorate добавляет отображаемые имена веток или теги коммитов; флаг --oneline записывает информацию о коммите в одну строку, что позволяет без труда просматривать множество коммитов сразу.

**Пояснения**

Команда git log является основным инструментом Git для изучения истории репозитория. С помощью этой команды можно найти конкретную версию проекта или определить изменения, которые будут внесены при выполнении слияния в функциональной ветке.

<table> <tr> <td bgcolor = #008000>commit 3157ee3718e180a9476bf2e5cab8e3f1e78a73b7
Author: John Smith</td> </tr> </table>

Большая часть этой информации проста для понимания, но все же первую строку стоит пояснить. Строка длиной 40 знаков, следующая за элементом commit, является контрольной суммой SHA‑1 содержимого коммита. Она играет роль механизма для обеспечения целостности коммита (при нарушении целостности контрольная сумма изменится) и служит для него уникальным идентификатором.

Этот идентификатор может использоваться в таких командах, как git log .., в качестве ссылки на конкретные коммиты. Так, команда git log 3157e..5ab91 отображает данные в диапазоне между коммитами с идентификаторами 3157e и 5ab91. Кроме контрольных сумм, на конкретные коммиты указывают имена веток (см. раздел Модуль веток) и ключевое слово HEAD, которое всегда ссылается на текущий коммит, будь то ветка или конкретный коммит.

Символ ~ используется для относительных ссылок на родительский элемент коммита. Например, 3157e~1 ссылается на коммит, предшествующий коммиту 3157e, а HEAD~3 находится на 3 уровня выше текущего коммита.

Все перечисленные методы идентификации позволяют выполнять различные действия с конкретными коммитами. Обычно отправной точкой таких операций выступает команда git log, поскольку она позволяет найти нужные коммиты.

**Пример**

В разделе Использование приводится множество примеров использования git log, однако следует помнить, что в одной команде можно объединить несколько параметров:

<table> <tr> <td bgcolor = #008000>git log --author="John Smith" -p hello.py</td> </tr> </table>

Эта команда выводит данные по всем изменениям, которые Джон Смит внес в файл hello.py.

Синтаксис «..» удобно использовать при сравнении веток. В следующем примере показана команда для вывода краткого обзора всех коммитов, которые включены в ветку some-feature и не включены в main.

<table> <tr> <td bgcolor = #008000>git log --oneline main..some-feature</td> </tr> </table>

